import Catamorphism from './Catamorphism';
import Result from './Result';
declare class Err<E, A> extends Result<E, A> {
    private error;
    constructor(error: E);
    getOrElse(fn: () => A): A;
    getOrElseValue(defaultValue: A): A;
    map<B>(fn: (_: A) => B): Result<E, B>;
    mapError<X>(fn: (err: E) => X): Result<X, A>;
    andThen<B>(fn: (_: A) => Result<E, B>): Result<E, B>;
    orElse<X>(fn: (err: E) => Result<X, A>): Result<X, A>;
    cata<B>(matcher: Catamorphism<E, A, B>): B;
    ap<B, C>(result: Result<E, B>): Result<E, C>;
    assign<K extends string, B>(k: K, other: Result<E, B> | ((a: A) => Result<E, B>)): Result<E, A & {
        [k in K]: B;
    }>;
    do(fn: (a: A) => void): Result<E, A>;
    elseDo(fn: (err: E) => void): Result<E, A>;
}
declare const err: <E, A>(e: E) => Result<E, A>;
export default Err;
export { err };
