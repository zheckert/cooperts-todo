import Catamorphism from './Catamorphism';
declare abstract class Result<E, A> {
    abstract getOrElse(fn: () => A): A;
    abstract getOrElseValue(defaultValue: A): A;
    abstract map<B>(fn: (_: A) => B): Result<E, B>;
    and<B>(fn: (_: A) => B): Result<E, B>;
    abstract mapError<X>(fn: (_: E) => X): Result<X, A>;
    abstract andThen<B>(fn: (_: A) => Result<E, B>): Result<E, B>;
    abstract orElse<X>(fn: (_: E) => Result<X, A>): Result<X, A>;
    abstract cata<B>(matcher: Catamorphism<E, A, B>): B;
    abstract assign<K extends string, B>(k: K, other: Result<E, B> | ((a: A) => Result<E, B>)): Result<E, A & {
        [k in K]: B;
    }>;
    abstract do(fn: (a: A) => void): Result<E, A>;
    abstract elseDo(fn: (err: E) => void): Result<E, A>;
}
export default Result;
