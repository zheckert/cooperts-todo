"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dict = exports.keyValuePairs = exports.oneOf = exports.nullable = exports.maybe = exports.at = exports.field = exports.array = exports.dateJSON = exports.dateISO = exports.date = exports.boolean = exports.number = exports.string = exports.fail = exports.succeed = void 0;
var date_fns_1 = require("date-fns");
var maybeasy_1 = require("maybeasy");
var resulty_1 = require("resulty");
var ErrorStringify_1 = require("./ErrorStringify");
var Decoder = (function () {
    function Decoder(fn) {
        var _this = this;
        this.fn = fn;
        this.map = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).map(f);
            });
        };
        this.and = this.map;
        this.andThen = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).andThen(function (v) { return f(v).decodeAny(value); });
            });
        };
        this.assign = function (k, other) {
            return _this.andThen(function (a) {
                var decoder = other instanceof Decoder ? other : other(a);
                return decoder.map(function (b) {
                    var _a;
                    return (__assign(__assign({}, Object(a)), (_a = {}, _a[k.toString()] = b, _a)));
                });
            });
        };
        this.do = function (fn) {
            return _this.map(function (v) {
                fn(v);
                return v;
            });
        };
        this.mapError = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).mapError(f);
            });
        };
        this.orElse = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).orElse(function (e) { return f(e).decodeAny(value); });
            });
        };
        this.elseDo = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).elseDo(f);
            });
        };
        this.decodeAny = function (value) { return _this.fn(value); };
        this.decodeJson = function (json) {
            try {
                var value = JSON.parse(json);
                return _this.decodeAny(value);
            }
            catch (e) {
                return resulty_1.err(e.message);
            }
        };
        this.toAnyFn = function () {
            return function (value) { return _this.decodeAny(value); };
        };
        this.toJsonFn = function () {
            return function (json) { return _this.decodeJson(json); };
        };
    }
    return Decoder;
}());
exports.default = Decoder;
var succeed = function (value) { return new Decoder(function (_) { return resulty_1.ok(value); }); };
exports.succeed = succeed;
var fail = function (message) { return new Decoder(function (_) { return resulty_1.err(message); }); };
exports.fail = fail;
exports.string = new Decoder(function (value) {
    if (typeof value !== 'string') {
        var stringified = ErrorStringify_1.stringify(value);
        var errorMsg = "I expected to find a string but instead I found " + stringified;
        return resulty_1.err(errorMsg);
    }
    return resulty_1.ok(value);
});
exports.number = new Decoder(function (value) {
    if (typeof value !== 'number') {
        var errorMsg = "I expected to find a number but instead I found " + ErrorStringify_1.stringify(value);
        return resulty_1.err(errorMsg);
    }
    return resulty_1.ok(value);
});
exports.boolean = new Decoder(function (value) {
    if (typeof value !== 'boolean') {
        var errorMsg = "I expected to find a boolean but instead found " + ErrorStringify_1.stringify(value);
        return resulty_1.err(errorMsg);
    }
    return resulty_1.ok(value);
});
exports.date = new Decoder(function (value) {
    var errMsg = function (v) { return "I expected a date but instead I found " + ErrorStringify_1.stringify(v); };
    return resulty_1.ok(value)
        .andThen(function (s) { return exports.string.map(function (v) { return new Date(v); }).decodeAny(s); })
        .orElse(function (n) { return exports.number.map(function (v) { return new Date(v); }).decodeAny(n); })
        .andThen(function (d) { return (isNaN(d.getTime()) ? resulty_1.err(value) : resulty_1.ok(d)); })
        .mapError(function () { return errMsg(value); });
});
exports.dateISO = new Decoder(function (value) {
    return resulty_1.ok(value)
        .andThen(function (v) { return exports.string.decodeAny(v); })
        .map(date_fns_1.parseISO)
        .andThen(function (d) {
        return date_fns_1.isValid(d) ? resulty_1.ok(d) : resulty_1.err("I expected an ISO date but instead I found " + ErrorStringify_1.stringify(value));
    });
});
exports.dateJSON = new Decoder(function (value) {
    return resulty_1.ok(value)
        .andThen(function (v) { return exports.string.decodeAny(v); })
        .map(date_fns_1.parseJSON)
        .andThen(function (d) {
        return date_fns_1.isValid(d) ? resulty_1.ok(d) : resulty_1.err("I expected an JSON date but instead I found " + ErrorStringify_1.stringify(value));
    });
});
var array = function (decoder) {
    return new Decoder(function (value) {
        if (!(value instanceof Array)) {
            var errorMsg = "I expected an array but instead I found " + ErrorStringify_1.stringify(value);
            return resulty_1.err(errorMsg);
        }
        var result = resulty_1.ok([]);
        var _loop_1 = function (idx) {
            result = decoder
                .decodeAny(value[idx])
                .andThen(function (v) { return result.map(function (vs) { return vs.concat([v]); }); })
                .mapError(function (e) { return e + ":\nerror found in an array at [" + idx + "]"; });
            if (result instanceof resulty_1.Err) {
                return "break";
            }
        };
        for (var idx = 0; idx < value.length; idx++) {
            var state_1 = _loop_1(idx);
            if (state_1 === "break")
                break;
        }
        return result;
    });
};
exports.array = array;
var field = function (name, decoder) {
    return new Decoder(function (value) {
        var errorMsg = function () {
            var stringified = ErrorStringify_1.stringify(value);
            var msg = "I expected to find an object with key '" + name + "' but instead I found " + stringified;
            return resulty_1.err(msg);
        };
        if (value == null) {
            return errorMsg();
        }
        if (!value.hasOwnProperty(name)) {
            return errorMsg();
        }
        var v = value[name];
        return decoder.decodeAny(v).mapError(function (e) { return e + ":\noccurred in a field named '" + name + "'"; });
    });
};
exports.field = field;
var at = function (path, decoder) {
    return new Decoder(function (value) {
        if (value == null) {
            return resulty_1.err("I found an error. Could not apply 'at' path to an undefined or null value.");
        }
        var val = value;
        var idx = 0;
        while (idx < path.length) {
            val = val[path[idx]];
            if (val === undefined) {
                var pathStr = ErrorStringify_1.stringify(path.slice(0, idx + 1));
                var valueStr = ErrorStringify_1.stringify(value);
                return resulty_1.err("I found an error in the 'at' path. I could not find path '" + pathStr + "' in " + valueStr);
            }
            idx += 1;
        }
        return decoder.decodeAny(val);
    });
};
exports.at = at;
var maybe = function (decoder) {
    return new Decoder(function (value) {
        return decoder.decodeAny(value).cata({
            Err: function (e) { return resulty_1.ok(maybeasy_1.nothing()); },
            Ok: function (v) { return resulty_1.ok(maybeasy_1.just(v)); },
        });
    });
};
exports.maybe = maybe;
var nullable = function (decoder) {
    return new Decoder(function (value) {
        if (value == null) {
            return resulty_1.ok(maybeasy_1.nothing());
        }
        return decoder.decodeAny(value).map(maybeasy_1.just);
    });
};
exports.nullable = nullable;
var oneOf = function (decoders) {
    return new Decoder(function (value) {
        if (decoders.length === 0) {
            return resulty_1.err('No decoders specified.');
        }
        var result = decoders.reduce(function (memo, decoder) {
            return memo.orElse(function (err1) { return decoder.decodeAny(value).mapError(function (err2) { return err1 + "\n" + err2; }); });
        }, resulty_1.err(''));
        return result.mapError(function (m) { return "I found the following problems:\n" + m; });
    });
};
exports.oneOf = oneOf;
var keyValuePairs = function (decoder) {
    return new Decoder(function (value) {
        if (typeof value !== 'object' || value === null || value instanceof Array) {
            return resulty_1.err("Expected to find an object and instead found '" + ErrorStringify_1.stringify(value) + "'");
        }
        return Object.keys(value).reduce(function (memo, key) {
            return memo.andThen(function (pairs) {
                return decoder
                    .decodeAny(value[key])
                    .mapError(function (err) { return "Key '" + key + "' failed to decode: " + err; })
                    .map(function (v) { return pairs.concat([[key, v]]); });
            });
        }, resulty_1.ok([]));
    });
};
exports.keyValuePairs = keyValuePairs;
var dict = function (decoder) {
    return exports.keyValuePairs(decoder).map(function (pairs) {
        return pairs.reduce(function (memo, _a) {
            var key = _a[0], value = _a[1];
            memo.set(key, value);
            return memo;
        }, new Map());
    });
};
exports.dict = dict;
//# sourceMappingURL=Decoder.js.map