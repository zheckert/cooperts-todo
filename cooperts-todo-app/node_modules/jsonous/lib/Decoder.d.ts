import { Maybe } from 'maybeasy';
import { Result } from 'resulty';
export declare type DecoderFn<A> = (thing: any) => Result<string, A>;
export default class Decoder<A> {
    private fn;
    constructor(fn: DecoderFn<A>);
    map: <B>(f: (a: A) => B) => Decoder<B>;
    and: <B>(f: (a: A) => B) => Decoder<B>;
    andThen: <B>(f: (a: A) => Decoder<B>) => Decoder<B>;
    assign: <K extends string, B>(k: K, other: Decoder<B> | ((a: A) => Decoder<B>)) => Decoder<A & { [k in K]: B; }>;
    do: (fn: (a: A) => void) => Decoder<A>;
    mapError: (f: (e: string) => string) => Decoder<A>;
    orElse: (f: (e: string) => Decoder<A>) => Decoder<A>;
    elseDo: (f: (e: string) => void) => Decoder<A>;
    decodeAny: (value: any) => Result<string, A>;
    decodeJson: (json: string) => Result<string, A>;
    toAnyFn: () => (value: any) => Result<string, A>;
    toJsonFn: () => (json: string) => Result<string, A>;
}
export declare const succeed: <A>(value: A) => Decoder<A>;
export declare const fail: <A>(message: string) => Decoder<A>;
export declare const string: Decoder<string>;
export declare const number: Decoder<number>;
export declare const boolean: Decoder<boolean>;
export declare const date: Decoder<Date>;
export declare const dateISO: Decoder<Date>;
export declare const dateJSON: Decoder<Date>;
export declare const array: <A>(decoder: Decoder<A>) => Decoder<A[]>;
export declare const field: <A>(name: string, decoder: Decoder<A>) => Decoder<A>;
export declare const at: <A>(path: Array<number | string>, decoder: Decoder<A>) => Decoder<A>;
export declare const maybe: <A>(decoder: Decoder<A>) => Decoder<Maybe<A>>;
export declare const nullable: <A>(decoder: Decoder<A>) => Decoder<Maybe<A>>;
export declare const oneOf: <A>(decoders: Decoder<A>[]) => Decoder<A>;
export declare const keyValuePairs: <A>(decoder: Decoder<A>) => Decoder<[string, A][]>;
export declare const dict: <A>(decoder: Decoder<A>) => Decoder<Map<string, A>>;
